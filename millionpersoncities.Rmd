```{r Initialization, include=FALSE}
options(width = 200)
load.project()
```
# What If Everyone Lived in the Big City, Round 1?

## US Cities Data

We are going to start with a matrix of US cities that will be the basis for a pairwise distance matrix.

```{r City Data}
head(loc)
dm <- rdist.earth(loc[,2:3], loc[,2:3], miles=TRUE)

# Setup names and zero out small values
rownames(dm) <- name
colnames(dm) <- name
dm[dm[] < 1] <- 0

# A sample of the data
dm[1:5,1:5]
```

## How do we move people?

The algoritm is that the following function will select the smallest remaining city and move its population to the closest city.

```{r Move Smallest to Closest Function}
# pop: Matrix holding population data information. Latest pass is the last column.
# dm: Distance matrix
# pass: Pass number
moveSmallestToClosest <- function(pop, dm) {
  # Find the smallest city in the last column
  smallest <- minindex.nonzero(pop[,ncol(pop)])
  
  # Find the closest city that still has population, other than itself
  # Multiply the vactor of distances from the smallest city by the population of all 
  # cities so that emptied out cities are ignored.
  closest <- minindex.nonzero(dm[smallest,] * pop[,ncol(pop)])
  
  #printf("PASS %d: Move %s (%d) to %s (%d) a distance of %f miles", ncol(pop), rownames(dm)[smallest], pop[smallest,1], rownames(dm)[closest], pop[closest,1], dm[smallest, closest])
  
  # Record the pass in the pop
  pass <- pop[,ncol(pop)]
  pass[closest] <- pass[closest] + pass[smallest]
  pass[smallest] <- 0
  pop <- cbind(pop, pass)
    
  return(pop)
}
```

Here's an example:

```{r Example Move}
temppop <- pop
temppop <- moveSmallestToClosest(temppop, dm)
```

## Move everyone!

Now lets start moving people until every city has over 1 million people.

```{r Move Everyone}
repeat {
  pop <- moveSmallestToClosest(pop, dm)
  
  # Get the latest pass
  pop.pass <- pop[,ncol(pop)]
  
  # Inspect just the cities that still have population
  pop.pass <- pop.pass[pop.pass > 0]
  smallcities <- length(pop.pass[pop.pass < 1e6])
  #printf("Small cities remaining: %d", smallcities)
                      
  if (smallcities == 0) {
    break
  }
}
```

This completes in `r ncol(pop)-1` passes and we end up with `r nrow(pop[pop[,ncol(pop)] > 0,])` cities:

```{r Table}
pop[pop[,ncol(pop)] > 0, c(1, ncol(pop))]
```

## Map

```{r Map}
map('state')
points(loc[,2], loc[,3], col='grey', pch=".", cex=5)
points(loc[pop[,ncol(pop)] > 0,2], loc[pop[,ncol(pop)] > 0,3], col='blue')
```

# References

* http://stackoverflow.com/questions/8509329/finding-nearest-neighbor-between-2-sets-of-dated-points